from pathlib import Path

include: "snakemake-scripts.py"

samples = get_samples("/fastq")

indexname = "minimal"

indexfiles = [
    "/index/bowtie2/{index}.1.bt2",
    "/index/bowtie2/{index}.2.bt2",
    "/index/bowtie2/{index}.3.bt2",
    "/index/bowtie2/{index}.4.bt2",
    "/index/bowtie2/{index}.rev.1.bt2",
    "/index/bowtie2/{index}.rev.2.bt2"]

# choose config to be paired, single or auto
mode = get_mode(samples)

# First rule defines the output of the snakemake file as its input
rule all:
    input:
        expand("mapped/{sample}.bam", sample=samples.keys()),
        "qc/multiqc.html"

# The order of all subsequent rules does not matter
rule bowtie2index:
    input:
        "/index/{index}.fasta"
    output:
        indexfiles
    log:
        "logs/index/{index}_bowtie2.log"
    shell:
        "bowtie2-build {input} /index/bowtie2/{wildcards.index} > {log}"

rule bowtie2align:
    input:
        sample=lambda wildcards: single_or_paired_input(wildcards,mode),
        index=expand(indexfiles, index=[indexname])
    output:
        "mapped/{sample}.bam"
    log:
        "logs/bowtie2/{sample}.log"
    params:
        index="/index/bowtie2/"+indexname,  # prefix of reference genome index
        extra=""
    threads: 8
    wrapper:
        "0.27.1/bio/bowtie2/align"
        
rule trimmomatic_se:
    input:
        "merged/{sample}_R1.fastq"
    output:
        temp("trimmed/single/{sample}_R1.fastq")
    log:
        "logs/trimmomatic/single/{sample}.log"
    params:
        # list of trimmers (see manual)
        trimmer=["TRAILING:3",
                 "LEADING:3",
                 "MINLEN:10",
                 "SLIDINGWINDOW:4:20",
                 "ILLUMINACLIP:NexteraPE-PE.fa:2:30:10"],
        # optional parameters
        extra="-phred33"
    wrapper:
        "0.27.1/bio/trimmomatic/se"
    

rule trimmomatic_pe:
    input:
        r1="merged/{sample}_R1.fastq",
        r2="merged/{sample}_R2.fastq"
    output:
        r1=temp("trimmed/paired/{sample}_R1.fastq"),
        r2=temp("trimmed/paired/{sample}_R2.fastq"),
        # reads where trimming entirely removed the mate
        r1_unpaired="trimmed/paired/{sample}_R1.unpaired.fastq",
        r2_unpaired="trimmed/paired/{sample}_R2.unpaired.fastq"
    log:
        "logs/trimmomatic/paired/{sample}.log"
    params:
        # list of trimmers (see manual)
        trimmer=["TRAILING:3",
                 "LEADING:3",
                 "MINLEN:10",
                 "SLIDINGWINDOW:4:20",
                 "ILLUMINACLIP:NexteraPE-PE.fa:2:30:10"],
        # optional parameters
        extra="-phred33"
    wrapper:
        "0.27.1/bio/trimmomatic/pe"
        
# include fastqc into the docker and write a rule that takes
# trimmed/{sample}_R1/R2.fastq as input
rule trimmedfastqc:
    input:
        lambda wildcards: single_or_paired_input(wildcards,mode)
    output:
        html="qc/fastqc/trimmed/{sample}.html",
        zip="qc/fastqc/trimmed/{sample}_fastqc.zip"
    params: ""
    log:
        "logs/fastqc/trimmed/{sample}.log"
    wrapper:
        "0.27.1/bio/fastqc"

rule multiqc:
    input:
        expand("logs/trimmomatic/{mode}/{sample}.log", mode=[mode], sample=samples.keys()),
        expand("qc/fastqc/trimmed/{sample}_fastqc.zip", sample=samples.keys()),
        expand("logs/bowtie2/{sample}.log", sample=samples.keys())
    output:
        "qc/multiqc.html"
    params:
        ""
    log:
        "logs/multiqc/multiqc.log"
    wrapper:
        "0.27.1/bio/multiqc"

rule merge:
    input:
        lambda wildcards: samples[wildcards.sample][wildcards.read]
    output:
        temp("merged/{sample}_R{read}.fastq")
    log:
        "logs/merging/{sample}_R{read}_merge.log"
    shell:
        """
        echo {input} | tr ' ' '\n' > {log};
        zcat {input} > {output}"""
     
rule clean:
    shell:
        "rm -rf /output/* /index/bowtie2"
